/*****************************************************************************   
*                                                                            *   
*              CONFIDENTIAL VISTEON CORPORATION                              *   
*                                                                            *   
* This is an unpublished work of authorship, which contains trade            *   
* secrets, created in 2016. Visteon Corporation owns all rights to           *   
* this work and intends to maintain it in confidence to preserve             *   
* its trade secret status. Visteon Corporation reserves the right,           *   
* under the copyright laws of the United States or those of any              *   
* other country that may have jurisdiction, to protect this work             *   
* as an unpublished work, in the event of an inadvertent or                  *   
* deliberate unauthorized publication. Visteon Corporation also              *   
* reserves its rights under all copyright laws to protect this               *   
* work as a published work, when appropriate. Those having access            *   
* to this work may not copy it, use it, modify it or disclose the            *   
* information contained in it without the written authorization              *   
* of Visteon Corporation.                                                    *   
*                                                                            *   
******************************************************************************/  
/*****************************************************************************   
                                                                                  
File Name        :  Rte_adapter.c 
Module Short Name:  file_name                                                          
VOBName          :   
Author           :  nvenkat5 () Generated from UML  
Description      :  Autogenerated file.                           
Organization     :  Driver Information Software Section,                         
                     Visteon Corporation                                          
----------------------------------------------------------------------------     
Compiler Name    :                                                               
Target Processor :                                                               
                                                                                  
*******************************************************************************/  
                                                                                  
 
                                                                                  
/*****************************************************************************   
*                                 System Includes                            *   
******************************************************************************/  
#include "Platform_Types.h"
#include "LAP_IPCL_adapter.h" 
#include "lib.h"
#include "DAT_COM.h"
#include "LAP_AVCV.h"

/*****************************************************************************   
*                                 Project Includes                           *   
******************************************************************************/  
/*****************************************************************************   
*                                 Macro Definitions                          *   
*----------------------------------------------------------------------------*   
* Definition of macro shall be followed by a comment that explains the       *   
* purpose of the macro.                                                      *   
******************************************************************************/  

/*****************************************************************************   
*                                 Manifest Constants                         *   
*----------------------------------------------------------------------------*   
* Definition of constant shall be followed by a comment that explains the    *   
* purpose of the constant.                                                   *   
******************************************************************************/  

IPCL_AVCVType	  		IPCL_AVCV_Data;				//PACKID = 0x4007 subid = 26
IPCL_MP5NaviType  		IPCL_MP5Navi_Data;			//PACKID = 0x4007 subid = 27

IPCL_MuenConfigRec 		IPCL_GetMenuConfig_Data;	//PACKID = 0x4009 subid = 67  viprx and tx

IPCL_AVCVType	  		HMI_IPCL_AVCV_Data;			//used for gdt phone & multimedia display
IPCL_MP5NaviType  		HMI_IPCL_MP5Navi_Data;		//used for gdt navigation display

U16 HMI_AVCV_Pb_Char[256] = {0};
U8 HMI_AVCV_Pl_Char[32] = {0};

/*============================================================================ 
**                                                                             
** Function Name:void IPCL_Adapter_DataInit  (uint8* p_signal_pointer)                                         
** 
** Traceability:PSA_P2D3_VIP_GIP_IF::PSA_P2D3_VIP_GIP_Interface::PSA_P2D3_VIP_Interface::TIMDLFuel
** 
** Return Type :void
** 
** Parameter :uint8* p_signal_pointer
** 
**==========================================================================*/
void  IPCL_Adapter_DataInit(void)
{
  mLIBmemset(&IPCL_AVCV_Data, 0, sizeof(IPCL_AVCVType));
  mLIBmemset(&IPCL_MP5Navi_Data, 0, sizeof(IPCL_MP5NaviType));

  mLIBmemset(&HMI_IPCL_AVCV_Data, 0, sizeof(IPCL_AVCVType));
  mLIBmemset(&HMI_IPCL_MP5Navi_Data, 0, sizeof(IPCL_MP5NaviType));
}

/*============================================================================ 
**                                                                             
** Function Name:void UpdateAVCVData  (uint8* p_signal_pointer)                                         
** 
** Traceability:
** 
** Return Type :void
** 
** Parameter :uint8* p_signal_pointer
** 
**==========================================================================*/
void UpdateAVCVData(uint8* p_signal_pointer)
{
	static U8	u8TXTimes;
	static U8 i;
	U8 u8Errflg = 0;
	U8 u8Num;

	u8Errflg = LAPAVCVGetErrorFlg(IPCL_AVCV_Data.AVCV_MesgType);
		
	switch(IPCL_AVCV_Data.AVCV_MesgType)
	{
		case AUDIO_DATA:
			if(u8Errflg == 1)
			{
				mLIBmemset(&IPCL_AVCV_Data, 0, sizeof(IPCL_AVCV_Data));		
				LAPAVCVSetErrorFlg(AUDIO_DATA,0);
			}
			else
			{
			#if 0
				if(IPCL_AVCV_Data.AVCV_AudioSrc == 0)
				{
					i++;
					if(i == 10)
					{
						mLIBmemcpy(p_signal_pointer, (void*)&IPCL_AVCV_Data  , sizeof(IPCL_AVCVType));
						i = 0;
					}
				}
				else
				{
					mLIBmemcpy(p_signal_pointer, (void*)&IPCL_AVCV_Data  , sizeof(IPCL_AVCVType));
					i = 0;
				}
			#endif
				mLIBmemcpy(p_signal_pointer, (void*)&IPCL_AVCV_Data  , sizeof(IPCL_AVCVType));
			}
			break;
		case PHONE_DATA:
			if(u8Errflg == 1)
			{
				mLIBmemset(&IPCL_AVCV_Data, 0, sizeof(IPCL_AVCV_Data));		
				LAPAVCVSetErrorFlg(PHONE_DATA,0);
			}
			else
			{
				mLIBmemcpy(p_signal_pointer, (void*)&IPCL_AVCV_Data  , sizeof(IPCL_AVCVType));
			}
			break;
		case PHONEBOOK_DATA_1_1:
		case PHONEBOOK_DATA_1_2:
		case PHONEBOOK_DATA_2_1:
		case PHONEBOOK_DATA_2_2:
		case PHONEBOOK_DATA_3_1:
		case PHONEBOOK_DATA_3_2:
		case PHONEBOOK_DATA_4_1:
		case PHONEBOOK_DATA_4_2:
			if(u8Errflg == 1)
			{
				mLIBmemset(&IPCL_AVCV_Data, 0, sizeof(IPCL_AVCV_Data));		
				LAPAVCVSetErrorFlg(PHONEBOOK_DATA_1_1,0);
			}
			else
			{
				mLIBmemcpy(p_signal_pointer, (void*)&IPCL_AVCV_Data  , sizeof(IPCL_AVCVType));
			}
			break;
		default:
			break;
							
	}		

	if(u8TXTimes<23)
	{
		DATACOM_WriteU8BitAVCVTransmitDefault(u8TXTimes);
		u8TXTimes++;		
	}
	else
	{	
		DATACOM_WriteU8BitAVCVTransmitDefault(u8TXTimes);
		u8TXTimes = 0;
	}

	switch (IPCL_AVCV_Data.AVCV_MesgType)
	{
		case PHONEBOOK_DATA_1_1:
			HMI_AVCV_Pl_Char[0] = IPCL_AVCV_Data.AVCV_Data_01;
			HMI_AVCV_Pl_Char[1] = IPCL_AVCV_Data.AVCV_Data_02;
			HMI_AVCV_Pl_Char[2] = IPCL_AVCV_Data.AVCV_Data_03;
			HMI_AVCV_Pl_Char[3] = IPCL_AVCV_Data.AVCV_Data_04;

			for(u8Num=0; u8Num<32; u8Num++)
			{
				*(HMI_AVCV_Pb_Char+u8Num) = IPCL_AVCV_Data.AVCV_Pb_Char[u8Num];
			}
			break;
			
		case PHONEBOOK_DATA_1_2:
			HMI_AVCV_Pl_Char[4] = IPCL_AVCV_Data.AVCV_Data_01;
			HMI_AVCV_Pl_Char[5] = IPCL_AVCV_Data.AVCV_Data_02;
			HMI_AVCV_Pl_Char[6] = IPCL_AVCV_Data.AVCV_Data_03;
			HMI_AVCV_Pl_Char[7] = IPCL_AVCV_Data.AVCV_Data_04;

			for(u8Num=0; u8Num<32; u8Num++)
			{
				*(HMI_AVCV_Pb_Char+32+u8Num) = IPCL_AVCV_Data.AVCV_Pb_Char[u8Num];
			}
			break;
			
		case PHONEBOOK_DATA_2_1:
			HMI_AVCV_Pl_Char[8] = IPCL_AVCV_Data.AVCV_Data_01;
			HMI_AVCV_Pl_Char[9] = IPCL_AVCV_Data.AVCV_Data_02;
			HMI_AVCV_Pl_Char[10] = IPCL_AVCV_Data.AVCV_Data_03;
			HMI_AVCV_Pl_Char[11] = IPCL_AVCV_Data.AVCV_Data_04;

			for(u8Num=0; u8Num<32; u8Num++)
			{
				*(HMI_AVCV_Pb_Char+64+u8Num) = IPCL_AVCV_Data.AVCV_Pb_Char[u8Num];
			}
			break;
			
		case PHONEBOOK_DATA_2_2:
			HMI_AVCV_Pl_Char[12] = IPCL_AVCV_Data.AVCV_Data_01;
			HMI_AVCV_Pl_Char[13] = IPCL_AVCV_Data.AVCV_Data_02;
			HMI_AVCV_Pl_Char[14] = IPCL_AVCV_Data.AVCV_Data_03;
			HMI_AVCV_Pl_Char[15] = IPCL_AVCV_Data.AVCV_Data_04;

			for(u8Num=0; u8Num<32; u8Num++)
			{
				*(HMI_AVCV_Pb_Char+96+u8Num) = IPCL_AVCV_Data.AVCV_Pb_Char[u8Num];
			}
			break;
			
		case PHONEBOOK_DATA_3_1:
			HMI_AVCV_Pl_Char[16] = IPCL_AVCV_Data.AVCV_Data_01;
			HMI_AVCV_Pl_Char[17] = IPCL_AVCV_Data.AVCV_Data_02;
			HMI_AVCV_Pl_Char[18] = IPCL_AVCV_Data.AVCV_Data_03;
			HMI_AVCV_Pl_Char[19] = IPCL_AVCV_Data.AVCV_Data_04;

			for(u8Num=0; u8Num<32; u8Num++)
			{
				*(HMI_AVCV_Pb_Char+128+u8Num) = IPCL_AVCV_Data.AVCV_Pb_Char[u8Num];
			}
			break;
			
		case PHONEBOOK_DATA_3_2:
			HMI_AVCV_Pl_Char[20] = IPCL_AVCV_Data.AVCV_Data_01;
			HMI_AVCV_Pl_Char[21] = IPCL_AVCV_Data.AVCV_Data_02;
			HMI_AVCV_Pl_Char[22] = IPCL_AVCV_Data.AVCV_Data_03;
			HMI_AVCV_Pl_Char[23] = IPCL_AVCV_Data.AVCV_Data_04;

			for(u8Num=0; u8Num<32; u8Num++)
			{
				*(HMI_AVCV_Pb_Char+160+u8Num) = IPCL_AVCV_Data.AVCV_Pb_Char[u8Num];
			}
			break;
			
		case PHONEBOOK_DATA_4_1:
			HMI_AVCV_Pl_Char[24] = IPCL_AVCV_Data.AVCV_Data_01;
			HMI_AVCV_Pl_Char[25] = IPCL_AVCV_Data.AVCV_Data_02;
			HMI_AVCV_Pl_Char[26] = IPCL_AVCV_Data.AVCV_Data_03;
			HMI_AVCV_Pl_Char[27] = IPCL_AVCV_Data.AVCV_Data_04;

			for(u8Num=0; u8Num<32; u8Num++)
			{
				*(HMI_AVCV_Pb_Char+192+u8Num) = IPCL_AVCV_Data.AVCV_Pb_Char[u8Num];
			}
			break;
			
		case PHONEBOOK_DATA_4_2:
			HMI_AVCV_Pl_Char[28] = IPCL_AVCV_Data.AVCV_Data_01;
			HMI_AVCV_Pl_Char[29] = IPCL_AVCV_Data.AVCV_Data_02;
			HMI_AVCV_Pl_Char[30] = IPCL_AVCV_Data.AVCV_Data_03;
			HMI_AVCV_Pl_Char[31] = IPCL_AVCV_Data.AVCV_Data_04;

			for(u8Num=0; u8Num<32; u8Num++)
			{
				*(HMI_AVCV_Pb_Char+224+u8Num) = IPCL_AVCV_Data.AVCV_Pb_Char[u8Num];
			}
			break;

		default:
			break;
	}
}

/*============================================================================ 
**                                                                             
** Function Name:void UpdateMP5NavigationData  (uint8* p_signal_pointer)                                         
** 
** Traceability:
** 
** Return Type :void
** 
** Parameter :uint8* p_signal_pointer
** 
**==========================================================================*/
void UpdateMP5NavigationData(uint8* p_signal_pointer)
{
	if(NaErrFlg == 1)
	{
		mLIBmemcpy(p_signal_pointer, (void*)&IPCL_MP5Navi_Data  , sizeof(IPCL_MP5NaviType));
		NaErrFlg = 0;
	}
	mLIBmemcpy(p_signal_pointer, (void*)&IPCL_MP5Navi_Data  , sizeof(IPCL_MP5NaviType));
	
	DATACOM_WriteU8BitNaviTransmitDefault(cTrue);
}

/*============================================================================ 
**                                                                             
** Function Name:void IPCL_UpdateAVCVStateData  (uint8* p_signal_pointer)                                         
** 
** Traceability: Send the MP5 data to GIP.
** 
** Return Type :
** 
** Parameter :
** 
**==========================================================================*/
void IPCL_UpdateAVCVStateData(void) 
{
	U8	u8Arrary;	

	// audio information ctrl variable
	IPCL_AVCV_Data.AVCV_AudioStatus = sAVCV_IPCL.AVCV_AudioStatus;
	IPCL_AVCV_Data.AVCV_AudioSrc = sAVCV_IPCL.AVCV_AudioSrc;
	
	// phone signal information ctrl variable
	IPCL_AVCV_Data.AVCV_PsCallType = sAVCV_IPCL.AVCV_PsCallType;
	IPCL_AVCV_Data.AVCV_PsCallSrc = sAVCV_IPCL.AVCV_PsCallSrc;

	// phone book information ctrl variable
	IPCL_AVCV_Data.AVCV_MesgType = sAVCV_IPCL.AVCV_MesgType;
	IPCL_AVCV_Data.AVCV_Data_01 = sAVCV_IPCL.AVCV_Data_01;
	IPCL_AVCV_Data.AVCV_Data_02 = sAVCV_IPCL.AVCV_Data_02;
	IPCL_AVCV_Data.AVCV_Data_03 = sAVCV_IPCL.AVCV_Data_03;
	IPCL_AVCV_Data.AVCV_Data_04 = sAVCV_IPCL.AVCV_Data_04;
    IPCL_AVCV_Data.AVCV_PlayTime = sAVCV_IPCL.AVCV_PlayTime;
    IPCL_AVCV_Data.AVCV_Duration = sAVCV_IPCL.AVCV_Duration;
	IPCL_AVCV_Data.AVCV_ScreenReq = sAVCV_IPCL.AVCV_ScreenReq;
	
	for(u8Arrary=0; u8Arrary<32; u8Arrary++)
	{
		IPCL_AVCV_Data.AVCV_Pb_Char[u8Arrary] = sAVCV_IPCL.AVCV_Pb_Char[u8Arrary];
	}
	
	for(u8Arrary=0; u8Arrary<40; u8Arrary++)
	{
		IPCL_AVCV_Data.AVCV_Ps_Char[u8Arrary] = sAVCV_IPCL.AVCV_Ps_Char[u8Arrary];
	}

    for(u8Arrary=0; u8Arrary<56; u8Arrary++)
	{
		IPCL_AVCV_Data.AVCV_Audio_Char[u8Arrary] = sAVCV_IPCL.AVCV_Audio_Char[u8Arrary];
	}
	
	sAVCV_IPCL.AVCV_ScreenReq = 0;
}

/*============================================================================ 
**                                                                             
** Function Name:void IPCL_UpdateAVCVStateData  (uint8* p_signal_pointer)                                         
** 
** Traceability: Send the MP5 data to GIP.
** 
** Return Type :
** 
** Parameter :
** 
**==========================================================================*/
void IPCL_UpdateMP5NaviStateData(void) 
{
	U8 u8Arrary16;

	IPCL_MP5Navi_Data.Navi_Switch = sMP5Navi_IPCL.Navi_Switch;
	IPCL_MP5Navi_Data.Navi_Sign = sMP5Navi_IPCL.Navi_Sign;
	//IPCL_MP5Navi_Data.Navi_RoundNum = sMP5Navi_IPCL.Navi_RoundNum;
	IPCL_MP5Navi_Data.Navi_Dist = sMP5Navi_IPCL.Navi_Dist;

	for(u8Arrary16=0; u8Arrary16<16; u8Arrary16++)
	{
		IPCL_MP5Navi_Data.Navi_Char[u8Arrary16] = sMP5Navi_IPCL.Navi_Char[u8Arrary16];
	}
}

